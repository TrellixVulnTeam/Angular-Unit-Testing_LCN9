{"ast":null,"code":"'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis}\n   */\n\n  var NEWLINE = '\\n';\n  var IGNORE_FRAMES = {};\n  var creationTrace = '__creationTrace__';\n  var ERROR_TAG = 'STACKTRACE TRACKING';\n  var SEP_TAG = '__SEP_TAG__';\n  var sepTemplate = SEP_TAG + '@[native]';\n\n  var LongStackTrace =\n  /** @class */\n  function () {\n    function LongStackTrace() {\n      this.error = getStacktrace();\n      this.timestamp = new Date();\n    }\n\n    return LongStackTrace;\n  }();\n\n  function getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n  }\n\n  function getStacktraceWithCaughtError() {\n    try {\n      throw getStacktraceWithUncaughtError();\n    } catch (err) {\n      return err;\n    }\n  } // Some implementations of exception handling don't create a stack trace if the exception\n  // isn't thrown, however it's faster not to actually throw the exception.\n\n\n  var error = getStacktraceWithUncaughtError();\n  var caughtError = getStacktraceWithCaughtError();\n  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\n  function getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n  }\n\n  function addErrorStack(lines, error) {\n    var trace = getFrames(error);\n\n    for (var i = 0; i < trace.length; i++) {\n      var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n        lines.push(trace[i]);\n      }\n    }\n  }\n\n  function renderLongStackTrace(frames, stack) {\n    var longTrace = [stack ? stack.trim() : ''];\n\n    if (frames) {\n      var timestamp = new Date().getTime();\n\n      for (var i = 0; i < frames.length; i++) {\n        var traceFrames = frames[i];\n        var lastTime = traceFrames.timestamp;\n        var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n        separator = separator.replace(/[^\\w\\d]/g, '_');\n        longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n        addErrorStack(longTrace, traceFrames.error);\n        timestamp = lastTime.getTime();\n      }\n    }\n\n    return longTrace.join(NEWLINE);\n  } // if Error.stackTraceLimit is 0, means stack trace\n  // is disabled, so we don't need to generate long stack trace\n  // this will improve performance in some test(some test will\n  // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\n  function stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n  }\n\n  Zone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function getLongStackTrace(error) {\n      if (!error) {\n        return undefined;\n      }\n\n      var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n      if (!trace) {\n        return error.stack;\n      }\n\n      return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n      if (stackTracesEnabled()) {\n        var currentTask = Zone.currentTask;\n        var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n        trace = [new LongStackTrace()].concat(trace);\n\n        if (trace.length > this.longStackTraceLimit) {\n          trace.length = this.longStackTraceLimit;\n        }\n\n        if (!task.data) task.data = {};\n\n        if (task.type === 'eventTask') {\n          // Fix issue https://github.com/angular/zone.js/issues/1195,\n          // For event task of browser, by default, all task will share a\n          // singleton instance of data object, we should create a new one here\n          // The cast to `any` is required to workaround a closure bug which wrongly applies\n          // URL sanitization rules to .data access.\n          task.data = Object.assign({}, task.data);\n        }\n\n        task.data[creationTrace] = trace;\n      }\n\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      if (stackTracesEnabled()) {\n        var parentTask = Zone.currentTask || error.task;\n\n        if (error instanceof Error && parentTask) {\n          var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n          try {\n            error.stack = error.longStack = longStack;\n          } catch (err) {}\n        }\n      }\n\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  };\n\n  function captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n      stackTraces.push(getFrames(new LongStackTrace().error));\n      captureStackTraces(stackTraces, count - 1);\n    }\n  }\n\n  function computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n      return;\n    }\n\n    var frames = [];\n    captureStackTraces(frames, 2);\n    var frames1 = frames[0];\n    var frames2 = frames[1];\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n\n      if (frame1.indexOf(ERROR_TAG) == -1) {\n        var match = frame1.match(/^\\s*at\\s+/);\n\n        if (match) {\n          sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < frames1.length; i++) {\n      var frame1 = frames1[i];\n      var frame2 = frames2[i];\n\n      if (frame1 === frame2) {\n        IGNORE_FRAMES[frame1] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  computeIgnoreFrames();\n});","map":{"version":3,"sources":["C:/Users/kevin95822/Desktop/Angular project/unit_testing/PSAngularUnitTestingCourse/node_modules/zone.js/dist/long-stack-trace-zone.js"],"names":["factory","define","amd","NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","i","length","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","concat","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2"],"mappings":"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","sourcesContent":["'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var NEWLINE = '\\n';\n    var IGNORE_FRAMES = {};\n    var creationTrace = '__creationTrace__';\n    var ERROR_TAG = 'STACKTRACE TRACKING';\n    var SEP_TAG = '__SEP_TAG__';\n    var sepTemplate = SEP_TAG + '@[native]';\n    var LongStackTrace = /** @class */ (function () {\n        function LongStackTrace() {\n            this.error = getStacktrace();\n            this.timestamp = new Date();\n        }\n        return LongStackTrace;\n    }());\n    function getStacktraceWithUncaughtError() {\n        return new Error(ERROR_TAG);\n    }\n    function getStacktraceWithCaughtError() {\n        try {\n            throw getStacktraceWithUncaughtError();\n        }\n        catch (err) {\n            return err;\n        }\n    }\n    // Some implementations of exception handling don't create a stack trace if the exception\n    // isn't thrown, however it's faster not to actually throw the exception.\n    var error = getStacktraceWithUncaughtError();\n    var caughtError = getStacktraceWithCaughtError();\n    var getStacktrace = error.stack ?\n        getStacktraceWithUncaughtError :\n        (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\n    function getFrames(error) {\n        return error.stack ? error.stack.split(NEWLINE) : [];\n    }\n    function addErrorStack(lines, error) {\n        var trace = getFrames(error);\n        for (var i = 0; i < trace.length; i++) {\n            var frame = trace[i];\n            // Filter out the Frames which are part of stack capturing.\n            if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n                lines.push(trace[i]);\n            }\n        }\n    }\n    function renderLongStackTrace(frames, stack) {\n        var longTrace = [stack ? stack.trim() : ''];\n        if (frames) {\n            var timestamp = new Date().getTime();\n            for (var i = 0; i < frames.length; i++) {\n                var traceFrames = frames[i];\n                var lastTime = traceFrames.timestamp;\n                var separator = \"____________________Elapsed \" + (timestamp - lastTime.getTime()) + \" ms; At: \" + lastTime;\n                separator = separator.replace(/[^\\w\\d]/g, '_');\n                longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n                addErrorStack(longTrace, traceFrames.error);\n                timestamp = lastTime.getTime();\n            }\n        }\n        return longTrace.join(NEWLINE);\n    }\n    // if Error.stackTraceLimit is 0, means stack trace\n    // is disabled, so we don't need to generate long stack trace\n    // this will improve performance in some test(some test will\n    // set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n    function stackTracesEnabled() {\n        // Cast through any since this property only exists on Error in the nodejs\n        // typings.\n        return Error.stackTraceLimit > 0;\n    }\n    Zone['longStackTraceZoneSpec'] = {\n        name: 'long-stack-trace',\n        longStackTraceLimit: 10,\n        // add a getLongStackTrace method in spec to\n        // handle handled reject promise error.\n        getLongStackTrace: function (error) {\n            if (!error) {\n                return undefined;\n            }\n            var trace = error[Zone.__symbol__('currentTaskTrace')];\n            if (!trace) {\n                return error.stack;\n            }\n            return renderLongStackTrace(trace, error.stack);\n        },\n        onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n            if (stackTracesEnabled()) {\n                var currentTask = Zone.currentTask;\n                var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n                trace = [new LongStackTrace()].concat(trace);\n                if (trace.length > this.longStackTraceLimit) {\n                    trace.length = this.longStackTraceLimit;\n                }\n                if (!task.data)\n                    task.data = {};\n                if (task.type === 'eventTask') {\n                    // Fix issue https://github.com/angular/zone.js/issues/1195,\n                    // For event task of browser, by default, all task will share a\n                    // singleton instance of data object, we should create a new one here\n                    // The cast to `any` is required to workaround a closure bug which wrongly applies\n                    // URL sanitization rules to .data access.\n                    task.data = Object.assign({}, task.data);\n                }\n                task.data[creationTrace] = trace;\n            }\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        },\n        onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n            if (stackTracesEnabled()) {\n                var parentTask = Zone.currentTask || error.task;\n                if (error instanceof Error && parentTask) {\n                    var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                    try {\n                        error.stack = error.longStack = longStack;\n                    }\n                    catch (err) {\n                    }\n                }\n            }\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    };\n    function captureStackTraces(stackTraces, count) {\n        if (count > 0) {\n            stackTraces.push(getFrames((new LongStackTrace()).error));\n            captureStackTraces(stackTraces, count - 1);\n        }\n    }\n    function computeIgnoreFrames() {\n        if (!stackTracesEnabled()) {\n            return;\n        }\n        var frames = [];\n        captureStackTraces(frames, 2);\n        var frames1 = frames[0];\n        var frames2 = frames[1];\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            if (frame1.indexOf(ERROR_TAG) == -1) {\n                var match = frame1.match(/^\\s*at\\s+/);\n                if (match) {\n                    sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < frames1.length; i++) {\n            var frame1 = frames1[i];\n            var frame2 = frames2[i];\n            if (frame1 === frame2) {\n                IGNORE_FRAMES[frame1] = true;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    computeIgnoreFrames();\n})));\n"]},"metadata":{},"sourceType":"script"}